---
interface Props {
  targetId?: string; // ID of textarea to insert text into
}

const { targetId = 'content' } = Astro.props;
---

<div class="voice-input-container flex items-center gap-2">
  <!-- Language selector -->
  <select
    id="language-select"
    class="px-3 py-2 rounded-lg border border-gray-300 dark:border-gray-600 bg-white dark:bg-gray-800 text-sm"
  >
    <option value="en-US">English (US)</option>
    <option value="en-GB">English (UK)</option>
    <option value="es-ES">Spanish</option>
    <option value="fr-FR">French</option>
    <option value="de-DE">German</option>
    <option value="it-IT">Italian</option>
    <option value="pt-BR">Portuguese (Brazil)</option>
    <option value="ja-JP">Japanese</option>
    <option value="zh-CN">Chinese (Simplified)</option>
    <option value="ko-KR">Korean</option>
  </select>

  <button
    id="voice-button"
    type="button"
    class="flex items-center justify-center px-3 py-2 rounded-lg bg-blue-500 hover:bg-blue-600 text-white transition-all disabled:opacity-50 disabled:cursor-not-allowed"
    aria-label="Start voice input"
  >
    <span id="mic-icon" class="text-xl">üé§</span>
  </button>

  <!-- Voice commands help -->
  <button
    id="help-button"
    type="button"
    class="px-3 py-2 rounded-lg bg-gray-200 dark:bg-gray-700 hover:bg-gray-300 dark:hover:bg-gray-600 transition-colors text-sm"
  >
    ‚ùì Commands
  </button>
</div>

<!-- Help Modal -->
<div id="help-modal" class="hidden fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50">
  <div class="bg-white dark:bg-gray-800 rounded-lg p-6 max-w-md mx-4">
    <h3 class="text-xl font-bold mb-4">Voice Commands</h3>
    <div class="space-y-3 text-sm">
      <div>
        <strong>Punctuation:</strong>
        <ul class="ml-4 mt-1 space-y-1">
          <li>‚Ä¢ Say "period" or "full stop" ‚Üí .</li>
          <li>‚Ä¢ Say "comma" ‚Üí ,</li>
          <li>‚Ä¢ Say "question mark" ‚Üí ?</li>
          <li>‚Ä¢ Say "exclamation mark" or "exclamation point" ‚Üí !</li>
          <li>‚Ä¢ Say "new line" or "new paragraph" ‚Üí line break</li>
        </ul>
      </div>
      <div>
        <strong>Text Commands:</strong>
        <ul class="ml-4 mt-1 space-y-1">
          <li>‚Ä¢ Say "clear text" ‚Üí clears all text</li>
          <li>‚Ä¢ Say "undo" ‚Üí removes last sentence</li>
        </ul>
      </div>
      <div>
        <strong>Tips:</strong>
        <ul class="ml-4 mt-1 space-y-1">
          <li>‚Ä¢ Speak clearly and at normal pace</li>
          <li>‚Ä¢ Click stop when finished</li>
          <li>‚Ä¢ Text appears as you speak</li>
        </ul>
      </div>
    </div>
    <button
      id="close-modal"
      class="mt-4 w-full bg-blue-500 hover:bg-blue-600 text-white px-4 py-2 rounded-lg transition-colors"
    >
      Got it!
    </button>
  </div>
</div>

<script define:vars={{ targetId }}>
  const button = document.getElementById('voice-button');
  const micIcon = document.getElementById('mic-icon');
  const languageSelect = document.getElementById('language-select');
  const helpButton = document.getElementById('help-button');
  const helpModal = document.getElementById('help-modal');
  const closeModal = document.getElementById('close-modal');
  
  // Get textarea with better error handling and dynamic detection
  let textarea = null;
  let currentTargetId = targetId;
  
  function getTextarea() {
    // Always check for the current target textarea
    const currentTextarea = document.getElementById(currentTargetId);
    if (currentTextarea && currentTextarea !== textarea) {
      textarea = currentTextarea;
      console.log('Textarea changed to:', currentTargetId);
    }
    
    if (!textarea) {
      textarea = document.getElementById(currentTargetId);
      if (!textarea) {
        console.error(`Textarea with id "${currentTargetId}" not found`);
        return null;
      }
    }
    return textarea;
  }
  
  // Function to update target textarea dynamically
  function updateTarget(newTargetId) {
    currentTargetId = newTargetId;
    textarea = null; // Reset to force re-detection
    console.log('Voice input target updated to:', newTargetId);
  }
  
  // Expose updateTarget globally for external use
  window.updateVoiceTarget = updateTarget;
  
  // Auto-detect textarea changes by monitoring focus events
  function setupTextareaDetection() {
    // Monitor all textareas and text inputs for focus
    document.addEventListener('focusin', (event) => {
      const target = event.target;
      if (target && (target.tagName === 'TEXTAREA' || target.tagName === 'INPUT')) {
        const targetId = target.id;
        if (targetId && targetId !== currentTargetId) {
          updateTarget(targetId);
          // Update button aria-label to show current target
          button.setAttribute('aria-label', `Voice input ‚Üí ${targetId}`);
          setTimeout(() => {
            button.setAttribute('aria-label', 'Start voice input');
          }, 2000);
        }
      }
    });
    
    // Also monitor for page changes (SPA navigation)
    const observer = new MutationObserver((mutations) => {
      mutations.forEach((mutation) => {
        if (mutation.type === 'childList') {
          // Check if new textareas were added
          mutation.addedNodes.forEach((node) => {
            if (node.nodeType === 1) { // Element node
              const textareas = node.querySelectorAll ? node.querySelectorAll('textarea, input[type="text"]') : [];
              textareas.forEach((textarea) => {
                if (textarea.id && textarea.id !== currentTargetId) {
                  console.log('New textarea detected:', textarea.id);
                }
              });
            }
          });
        }
      });
    });
    
    observer.observe(document.body, {
      childList: true,
      subtree: true
    });
    
    console.log('Textarea detection setup complete');
  }
  
  // Initialize textarea detection
  setupTextareaDetection();

  // Check if browser supports speech recognition
  const SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;

  // Debug: Log component initialization
  console.log('VoiceInput component initializing...');
  console.log('Target ID:', targetId);
  console.log('Textarea found:', !!getTextarea());

  if (!SpeechRecognition) {
    button.disabled = true;
    statusText.textContent = 'Not supported';
    languageSelect.disabled = true;
    console.error('Speech Recognition not supported in this browser');
  } else {
    const recognition = new SpeechRecognition();
    
    // Configuration
    recognition.continuous = true;
    recognition.interimResults = true;
    recognition.lang = languageSelect.value;
    recognition.maxAlternatives = 1;

    let isListening = false;
    let finalTranscript = '';

    // Language change handler
    languageSelect.addEventListener('change', () => {
      recognition.lang = languageSelect.value;
      // Save preference
      localStorage.setItem('voiceInputLanguage', languageSelect.value);
    });

    // Load saved language preference
    const savedLang = localStorage.getItem('voiceInputLanguage');
    if (savedLang) {
      languageSelect.value = savedLang;
      recognition.lang = savedLang;
    }

    // Voice command processing
    function processVoiceCommand(text) {
      const lowerText = text.toLowerCase().trim();
      const targetTextarea = getTextarea();
      
      if (!targetTextarea) return text + ' ';
      
      // Punctuation commands
      if (lowerText.includes('period') || lowerText.includes('full stop')) {
        return text.replace(/period|full stop/gi, '.') + ' ';
      }
      if (lowerText.includes('comma')) {
        return text.replace(/comma/gi, ',') + ' ';
      }
      if (lowerText.includes('question mark')) {
        return text.replace(/question mark/gi, '?') + ' ';
      }
      if (lowerText.includes('exclamation mark') || lowerText.includes('exclamation point')) {
        return text.replace(/exclamation mark|exclamation point/gi, '!') + ' ';
      }
      if (lowerText.includes('new line') || lowerText.includes('new paragraph')) {
        return '\n\n';
      }
      
      // Text commands
      if (lowerText === 'clear text' || lowerText === 'clear all') {
        targetTextarea.value = '';
        finalTranscript = '';
        return '';
      }
      if (lowerText === 'undo' || lowerText === 'delete last') {
        const sentences = targetTextarea.value.split('. ');
        sentences.pop();
        targetTextarea.value = sentences.join('. ');
        if (targetTextarea.value && !targetTextarea.value.endsWith('.')) {
          targetTextarea.value += '.';
        }
        return '';
      }
      
      return text + ' ';
    }

    // Start/Stop button
    button.addEventListener('click', () => {
      if (isListening) {
        recognition.stop();
      } else {
        finalTranscript = '';
        try {
          recognition.start();
        } catch (error) {
          console.error('Recognition start error:', error);
        }
      }
    });

    recognition.onstart = () => {
      isListening = true;
      micIcon.textContent = '‚èπÔ∏è';
      button.setAttribute('aria-label', 'Stop voice input');
      button.classList.add('animate-pulse', 'bg-red-500', 'hover:bg-red-600');
      button.classList.remove('bg-blue-500', 'hover:bg-blue-600');
    };

    recognition.onresult = (event) => {
      let interimTranscript = '';
      const targetTextarea = getTextarea();
      
      if (!targetTextarea) {
        console.error('Textarea not found during result processing');
        return;
      }

      // Process results properly to avoid duplication
      for (let i = event.resultIndex; i < event.results.length; i++) {
        const transcript = event.results[i][0].transcript;
        
        if (event.results[i].isFinal) {
          // Add final transcript to the permanent text
          const processed = processVoiceCommand(transcript);
          finalTranscript += processed;
        } else {
          // Store interim transcript for live preview
          interimTranscript = transcript;
        }
      }

      // Update textarea with final + interim text
      targetTextarea.value = finalTranscript + interimTranscript;
      
      // Auto-scroll to bottom
      targetTextarea.scrollTop = targetTextarea.scrollHeight;
      
      // Trigger input event to notify other scripts
      targetTextarea.dispatchEvent(new Event('input', { bubbles: true }));
      
      console.log('Voice input updated:', targetTextarea.value);
    };

    recognition.onerror = (event) => {
      console.error('Speech recognition error:', event.error);
      
      let errorMessage = 'Error';
      switch(event.error) {
        case 'no-speech':
          errorMessage = 'No speech detected';
          break;
        case 'audio-capture':
          errorMessage = 'Microphone error';
          break;
        case 'not-allowed':
          errorMessage = 'Microphone permission denied';
          break;
        case 'network':
          errorMessage = 'Network error';
          break;
        default:
          errorMessage = `Error: ${event.error}`;
      }
      
      button.setAttribute('aria-label', `Voice input error: ${errorMessage}`);
      
      // Reset after showing error
      setTimeout(() => {
        if (!isListening) {
          button.setAttribute('aria-label', 'Start voice input');
        }
      }, 3000);
    };

    recognition.onend = () => {
      isListening = false;
      micIcon.textContent = 'üé§';
      button.setAttribute('aria-label', 'Start voice input');
      button.classList.remove('animate-pulse', 'bg-red-500', 'hover:bg-red-600');
      button.classList.add('bg-blue-500', 'hover:bg-blue-600');
      
      // Finalize the transcript by adding any remaining interim text
      const targetTextarea = getTextarea();
      if (targetTextarea) {
        // Ensure any remaining interim text is added to final
        const currentValue = targetTextarea.value;
        if (currentValue !== finalTranscript) {
          finalTranscript = currentValue;
        }
        targetTextarea.dispatchEvent(new Event('input', { bubbles: true }));
        console.log('Final transcript saved:', finalTranscript);
      }
    };
  }

  // Help modal handlers
  helpButton.addEventListener('click', () => {
    helpModal.classList.remove('hidden');
  });

  closeModal.addEventListener('click', () => {
    helpModal.classList.add('hidden');
  });

  helpModal.addEventListener('click', (e) => {
    if (e.target === helpModal) {
      helpModal.classList.remove('hidden');
    }
  });
</script>

<style>
  .animate-pulse {
    animation: pulse 2s cubic-bezier(0.4, 0, 0.6, 1) infinite;
  }

  @keyframes pulse {
    0%, 100% {
      opacity: 1;
    }
    50% {
      opacity: .7;
    }
  }
</style>
